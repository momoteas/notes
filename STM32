一、第1-8章：

1. FSMC: flexible static memory controller;

2. AHB到APB桥：从AHB总线延伸出来两条APB2和APB1总线，我们常说的GPIO，串口，I2C，SPI这些外设就挂载在这两条总线上；

3. 系统总线：主要是访问外设的寄存器，即读写寄存器都是通过这根系统总线完成的；

4. RCC：P35，复位和时钟控制；

5. 存储器映射: 在图6-4中（P35），被控制单元的Flash, RAM, FSMC, 和AHB到APB桥（即片上外设），这些功能部件共同排列在一个4GB的地址空间内；

6. 存储器映射：给存储器分配地址的过程就称为存储器映射，见图6-5（P36）；

7. Block2：片上外设，地址范围 0x4000 0000 ~ 0x5FFF FFFF（512MB）

8. Block0: 内部Flash; Block1: 内部RAM；

9. 储存器Block2内部区域功能划分：根据外设的总线速度不同，被分成了APB和AHB两部分，其中APB又被分为APB1和APB2；

10. APB1总线外设：0x4000 0000 ~ 0x4000 77FF; APB2总线外设：0x4001 0000 ~ 0x4001 3FFF; AHP总线外设：0x4001 8000 ~ 0x5003 FFFF;

11. GPIO属于高速外设，挂载到APB2总线上，具体见表6-6（P39）；

12. GPIO是通用输入输出端口的简称，简单来说就是STM32可控制的引脚，基本功能是控制引脚输出高电平或低电平；

13. 每个GPI/O端口有2个32位配置寄存器（GPIOx_CRL, GPIOx_CRH），2个32位数据寄存器（GPIOx_IDR和GPIOx_ODR），1个32位置位/复位寄存器（GPIOx_BSRR），
    1个16位复位寄存器（GPIOx_BRR）和1个32位锁定寄存器（GPIOx_LCKR）;
    
14. 外设基地址：PERIPH_BASE; 在此基础上定义总线基地址：APB1PERIPH_BASE，APB2PERIPH_BASE, AHBPERIPH_BASE，在此基础上定义GPIO外设基地址：
    GPIOA_BASE, GPIOB_BASE, ... GPIOG_BASE; 在此基础上定义寄存器基地址（以GPIOB为例）：GPIOB_CRL, GPIOB_CRH, GPIOB_IDR, GPIOB_ODR, 
    GPIOB_BSRR, GPIOB_BRR, GPIOB_LCKR;
    
15. 最后，我们更进一步，直接使用宏定义好GPIO——TypeDef类型的指针，而且指针指向各个GPIO端口的首地址，使用时我们直接用该宏访问寄存器即可；
   （#define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)） P43
   
16. STM32芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。STM32芯片的GPIO被分成很多组，每组16个引脚，如GPIOA, GPIOB,
    ... GPIOG
    
17. 推挽输出&开漏输出模式：P55（STM32零死角）；

18. 推挽输出一般用在输出电平为0和3.3v而且需要高速切换开关状态的场合；

19. 开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中。除此之外，还用在电平不匹配的场合；

20. 输出数据寄存器：（P57）我们通过修改输出数据寄存器的值就可以修改GPIO引脚的输出电平。而“置位/复位寄存器GPIOx_BSRR”可以通过修改输出数据寄存器的
    值从而影响电路的输出；
    
21. 复用功能输出：（P57）“复用”是指STM32的其它片上外设对GPIO引脚进行控制，此时GPIO引脚用作该外设功能的一部分，算是第二用途；
    例如我们使用USART串口通讯时，需要用到某个GPIO引脚作为通讯发送引脚，这个时候就可以把该GPIO引脚配置成USART串口复用功能，由串口外设控制该引脚，发送数据；
    
22. 输入数据寄存器：（P57）看GPIO结构框图的上半部分，GPIO引脚经过内部的上、下拉电阻，可以配置成上/下拉输入，然后再连接到施密特触发器，信号经过
    触发器后，模拟信号转化为0、1的数字信号，然后存储在“输入数据寄存器GPIOx_IDR”中，通过读取该寄存器就可以了解GPIO引脚的电平状态；
    
23. 复用功能输入：（P58）与“复用功能输出”模式类似，在“复用功能输入模式”时，GPIO引脚的信号传输到STM32其它片上外设，由该外设读取引脚状态；

24. 模拟输入输出：（P58）STM32零死角

25. GPIO工作模式：（P58）GPIOMode_TypeDef：模拟输入，浮空输入，下拉输入，上拉输入，开漏输出，推挽输出，复用开漏输出，复用推挽输出；

26. 输入模式（模拟/浮空/上拉/下拉）：（P58）在输入模式时，施密特触发器打开，输出被禁止，可以通过输入数据寄存器GPIOx_IDR读取I/O状态；
    其中输入模式，可设置为上拉、下拉、浮空和模拟输入四种。上拉和下拉输入很好理解，默认的电平由上拉或者下拉决定。浮空输入的电平是不确定的，
    完全由外部的输入决定，一般接按键的时候用的是这个模式。模拟输入则用于 ADC 采集；
    
27. 输出模式（推挽/开漏）: （P59） 在输出模式中，推挽模式时双 MOS 管以轮流方式工作，输出数据寄存器 GPIOx_ODR可控制 I/O 输出高低电平。
    开漏模式时，只有 N-MOS 管工作，输出数据寄存器可控制 I/O输出高阻态或低电平。输出速度可配置，有 2MHz\10MHz\50MHz 的选项。
    此处的输出速度即 I/O 支持的高低电平状态最高切换频率，支持的频率越高，功耗越大，如果功耗要求不严格，把速度设置成最大即可。
    在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器 GPIOx_IDR可读取 I/O 的实际状态。
    
28. 复用功能（推挽/开漏）：复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出信号源于其它外设，输出数据寄存器 GPIOx_ODR 
    无效；输入可用，通过输入数据寄存器可获取 I/O 实际状态，但一般直接用外设的寄存器来获取该数据信号；通过对 GPIO 寄存器写入不同的参数，
    就可以改变 GPIO 的工作模式，
    在 GPIO 外设中，控制端口高低控制寄存器 CRH 和 CRL 可以配置每个 GPIO 的工作模式和工作的速度，每 4 个位控制一个 IO，CRH 控制端口的高八位，
    CRL 控制端口的低 8 位，具体的看 CRH 和 CRL 的寄存器描述；

29. GPIOx_CRL & GPIOx_CRH: 每个引脚占用4个寄存器位。MODE位用来配置输出的速度，CNF位用来配置各种输入输出模式；

30. 控制引脚输出电平：（P66）在输出模式时，对端口位设置/清除寄存器BSRR寄存器、端口位清除寄存器BRR和ODR寄存器写入参数即可控制引脚的电平状态，其中
    操作BSRR和BRR最终影响的都是ODR寄存器，然后再通过ODR寄存器的输出来控制GPIO；
    
31. 开启外设时钟：由于STM32的外设很多，为了降低功耗，每个外设都对应着一个时钟，在芯片刚上电的时候这些时钟都是被关闭的，如果想要外设工作，必须把
    相应的时钟打开。STM32 的所有外设的时钟由一个专门的外设来管理，叫RCC（reset and clockcontrol），RCC 在《STM32 中文参考手册》的第六章。
    所有的GPIO都挂载到APB2总线上，具体的时钟由APB2外设时钟使能寄存器(RCC_APB2ENR)来控制；
    图8-11APB2外设时钟使能寄存器（P68）
    

二、第9章 自己写库—构建库函数雏形

1. APB2外设时钟使能寄存器(RCC_APB2ENR) ：STM32F01x-中文参考手册 P70；

2. 定义位操作函数：玩转STM32 P73
    voidGPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_tGPIO_Pin)，函数功能：设置引脚为高电平；
    voidGPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_tGPIO_Pin)，函数功能：设置引脚为低电平；
    
3. /*GPIO引脚号定义*/： 玩转STM32 P75
   GPIO_Pin_0, ... GPIO_Pin_15;












