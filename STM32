一、第1-8章：

1. FSMC: flexible static memory controller;

2. AHB到APB桥：从AHB总线延伸出来两条APB2和APB1总线，我们常说的GPIO，串口，I2C，SPI这些外设就挂载在这两条总线上；

3. 系统总线：主要是访问外设的寄存器，即读写寄存器都是通过这根系统总线完成的；

4. RCC：P35，复位和时钟控制；

5. 存储器映射: 在图6-4中（P35），被控制单元的Flash, RAM, FSMC, 和AHB到APB桥（即片上外设），这些功能部件共同排列在一个4GB的地址空间内；

6. 存储器映射：给存储器分配地址的过程就称为存储器映射，见图6-5（P36）；

7. Block2：片上外设，地址范围 0x4000 0000 ~ 0x5FFF FFFF（512MB）

8. Block0: 内部Flash; Block1: 内部RAM；

9. 储存器Block2内部区域功能划分：根据外设的总线速度不同，被分成了APB和AHB两部分，其中APB又被分为APB1和APB2；

10. APB1总线外设：0x4000 0000 ~ 0x4000 77FF; APB2总线外设：0x4001 0000 ~ 0x4001 3FFF; AHP总线外设：0x4001 8000 ~ 0x5003 FFFF;

11. GPIO属于高速外设，挂载到APB2总线上，具体见表6-6（P39）；

12. GPIO是通用输入输出端口的简称，简单来说就是STM32可控制的引脚，基本功能是控制引脚输出高电平或低电平；

13. 每个GPI/O端口有2个32位配置寄存器（GPIOx_CRL, GPIOx_CRH），2个32位数据寄存器（GPIOx_IDR和GPIOx_ODR），1个32位置位/复位寄存器（GPIOx_BSRR），
    1个16位复位寄存器（GPIOx_BRR）和1个32位锁定寄存器（GPIOx_LCKR）;
    
14. 外设基地址：PERIPH_BASE; 在此基础上定义总线基地址：APB1PERIPH_BASE，APB2PERIPH_BASE, AHBPERIPH_BASE，在此基础上定义GPIO外设基地址：
    GPIOA_BASE, GPIOB_BASE, ... GPIOG_BASE; 在此基础上定义寄存器基地址（以GPIOB为例）：GPIOB_CRL, GPIOB_CRH, GPIOB_IDR, GPIOB_ODR, 
    GPIOB_BSRR, GPIOB_BRR, GPIOB_LCKR;
    
15. 最后，我们更进一步，直接使用宏定义好GPIO——TypeDef类型的指针，而且指针指向各个GPIO端口的首地址，使用时我们直接用该宏访问寄存器即可；
   （#define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)） P43
   
16. STM32芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。STM32芯片的GPIO被分成很多组，每组16个引脚，如GPIOA, GPIOB,
    ... GPIOG
    
17. 推挽输出&开漏输出模式：P55（STM32零死角）；

18. 推挽输出一般用在输出电平为0和3.3v而且需要高速切换开关状态的场合；

19. 开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中。除此之外，还用在电平不匹配的场合；

20. 输出数据寄存器：（P57）我们通过修改输出数据寄存器的值就可以修改GPIO引脚的输出电平。而“置位/复位寄存器GPIOx_BSRR”可以通过修改输出数据寄存器的
    值从而影响电路的输出；
    
21. 复用功能输出：（P57）“复用”是指STM32的其它片上外设对GPIO引脚进行控制，此时GPIO引脚用作该外设功能的一部分，算是第二用途；
    例如我们使用USART串口通讯时，需要用到某个GPIO引脚作为通讯发送引脚，这个时候就可以把该GPIO引脚配置成USART串口复用功能，由串口外设控制该引脚，发送数据；
    
22. 输入数据寄存器：（P57）看GPIO结构框图的上半部分，GPIO引脚经过内部的上、下拉电阻，可以配置成上/下拉输入，然后再连接到施密特触发器，信号经过
    触发器后，模拟信号转化为0、1的数字信号，然后存储在“输入数据寄存器GPIOx_IDR”中，通过读取该寄存器就可以了解GPIO引脚的电平状态；
    
23. 复用功能输入：（P58）与“复用功能输出”模式类似，在“复用功能输入模式”时，GPIO引脚的信号传输到STM32其它片上外设，由该外设读取引脚状态；

24. 模拟输入输出：（P58）STM32零死角

25. GPIO工作模式：（P58）GPIOMode_TypeDef：模拟输入，浮空输入，下拉输入，上拉输入，开漏输出，推挽输出，复用开漏输出，复用推挽输出；

26. 输入模式（模拟/浮空/上拉/下拉）：（P58）在输入模式时，施密特触发器打开，输出被禁止，可以通过输入数据寄存器GPIOx_IDR读取I/O状态；
    其中输入模式，可设置为上拉、下拉、浮空和模拟输入四种。上拉和下拉输入很好理解，默认的电平由上拉或者下拉决定。浮空输入的电平是不确定的，
    完全由外部的输入决定，一般接按键的时候用的是这个模式。模拟输入则用于 ADC 采集；
    
27. 输出模式（推挽/开漏）: （P59） 在输出模式中，推挽模式时双 MOS 管以轮流方式工作，输出数据寄存器 GPIOx_ODR可控制 I/O 输出高低电平。
    开漏模式时，只有 N-MOS 管工作，输出数据寄存器可控制 I/O输出高阻态或低电平。输出速度可配置，有 2MHz\10MHz\50MHz 的选项。
    此处的输出速度即 I/O 支持的高低电平状态最高切换频率，支持的频率越高，功耗越大，如果功耗要求不严格，把速度设置成最大即可。
    在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器 GPIOx_IDR可读取 I/O 的实际状态。
    
28. 复用功能（推挽/开漏）：复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出信号源于其它外设，输出数据寄存器 GPIOx_ODR 
    无效；输入可用，通过输入数据寄存器可获取 I/O 实际状态，但一般直接用外设的寄存器来获取该数据信号；通过对 GPIO 寄存器写入不同的参数，
    就可以改变 GPIO 的工作模式，
    在 GPIO 外设中，控制端口高低控制寄存器 CRH 和 CRL 可以配置每个 GPIO 的工作模式和工作的速度，每 4 个位控制一个 IO，CRH 控制端口的高八位，
    CRL 控制端口的低 8 位，具体的看 CRH 和 CRL 的寄存器描述；

29. GPIOx_CRL & GPIOx_CRH: 每个引脚占用4个寄存器位。MODE位用来配置输出的速度，CNF位用来配置各种输入输出模式；

30. 控制引脚输出电平：（P66）在输出模式时，对端口位设置/清除寄存器BSRR寄存器、端口位清除寄存器BRR和ODR寄存器写入参数即可控制引脚的电平状态，其中
    操作BSRR和BRR最终影响的都是ODR寄存器，然后再通过ODR寄存器的输出来控制GPIO；
    
31. 开启外设时钟：由于STM32的外设很多，为了降低功耗，每个外设都对应着一个时钟，在芯片刚上电的时候这些时钟都是被关闭的，如果想要外设工作，必须把
    相应的时钟打开。STM32 的所有外设的时钟由一个专门的外设来管理，叫RCC（reset and clockcontrol），RCC 在《STM32 中文参考手册》的第六章。
    所有的GPIO都挂载到APB2总线上，具体的时钟由APB2外设时钟使能寄存器(RCC_APB2ENR)来控制；
    图8-11APB2外设时钟使能寄存器（P68）
    

二、第9章 自己写库—构建库函数雏形

1. APB2外设时钟使能寄存器(RCC_APB2ENR) ：STM32F01x-中文参考手册 P70；

2. 定义位操作函数：玩转STM32 P73
    voidGPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_tGPIO_Pin)，函数功能：设置引脚为高电平；
    voidGPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_tGPIO_Pin)，函数功能：设置引脚为低电平；
    
3. /*GPIO引脚号定义*/： 玩转STM32 P75
   GPIO_Pin_0, ... GPIO_Pin_15;
   
4. 定义初始化结构体GPIO_InitTypeDef:（P76）定义位操作函数后，控制GPIO输出电平的代码得到了简化，但在控制GPIO输出电平前还需要初始化GPIO引脚的各种模式

5. 定义引脚模式的枚举类型：（P77）GPIOSpeed_TypeDef 和 GPIOMode_TypeDef；
   代码9-5使用枚举定义的GPIO初始化结构体：P79；
   代码清单9-7给GPIO_InitTypeDef初始化结构体赋值范例：P79
   
6. 定义GPIO初始化函数：P80 接着前面的思路，对初始化结构体赋值后，把它输入到GPIO初始化函数，由它来实现寄存器配置。我们的GPIO初始化函数实现见代码9-6。
   voidGPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)


三、初识STM32标准库

1. 常用官方资料：P93


四、第12章 GPIO输出—使用固件库点亮LED

1. GPIO时钟宏“RCC_APB2Periph_GPIOB：是STM32标准库定义的GPIO端口时钟相关的宏，它的作用与“GPIO_Pin_x”这类宏类似，是用于指示寄存器位的，方便库函数使用；使用

2. RCC_APB2PeriphClockCmd：（P110） 调用库函数RCC_APB2PeriphClockCmd来使能LED灯的GPIO端口时钟；
   GPIO_Init：调用库函数，初始化GPIO；


五、第13章 GPIO输入—按键检测

1. 编程要点：
   （1）使能GPIO端口时钟；（2）初始化GPIO目标引脚为输入模式(浮空输入)；（3）编写简单测试程序，检测按键的状态，实现按键控制LED灯。
   
2. GPIO_ReadInputDataBit(GPIOx,GPIO_Pin)：STM32标准库提供了库函数GPIO_ReadInputDataBit来获取位状态，该函数输入GPIO端口及引脚号，函数
   返回该引脚的电平状态，高电平返回1，低电平返回0；
   

六、第14章 GPIO—位带操作

1. 位带简介：
   在STM32中，有两个地方实现了位带，一个是SRAM区的最低1MB空间，令一个是外设区最低1MB空间。这两个1MB的空间除了可以像正常的RAM一样操作外，他们还有
   自己的位带别名区，位带别名区把这1MB的空间的每一个位膨胀成一个32位的字，当访问位带别名区的这些字时，就可以达到访问位带区某个比特位的目的。
   P121；
   
2. STM32 的全部寄存器都可以通过访问位带别名区的方式来达到访问原始寄存器比特位的效果；


七、第16章 RCC—使用 HSE/HSI 配置时钟

1. RCC 主要作用—时钟部分：
   设置系统时钟 SYSCLK、设置 AHB 分频因子（决定 HCLK 等于多少）、设置 APB2 分频因子（决定 PCLK2 等于多少）、设置 APB1 分频因子（决定 PCLK1 
   等于多少）、设置各个外设的分频因子；控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。对于 SYSCLK、HCLK、PCLK2、PCLK1 
   这四个时钟的配置一般是：PCLK2 = HCLK = SYSCLK=PLLCLK = 72M，PCLK1=HCLK/2 = 36M。这个时钟配置也是库函数的标准配置，我们用的最多的就是这个；
   
2. 图 16-1 STM32 时钟树：P135

3. HSE 高速外部时钟信号；
   PLL 时钟源：PLL时钟来源可以有两个，一个来自HSE，另外一个是HSI/2，具体用哪个由时钟配置寄存器CFGR的位16：PLLSRC设置。HSI是内部高速的时钟信号
   PLL时钟PLLCLK
   系统时钟SYSCLK：系统时钟来源可以是：HSI、PLLCLK、HSE，具体的时钟配置寄存器CFGR的位1-0：SW[1:0]设置
   AHB总线时钟HCLK：系统时钟SYSCLK经过AHB预分频器分频之后得到时钟叫APB总线时钟，即HCLK
   APB2总线时钟HCLK2：APB2总线时钟PCLK2由HCLK经过高速APB2预分频器得到，分频因子可以是:[1,2,4，8，16]，具体由时钟配置寄存器CFGR的位13-11：PPRE2[2:0]决定
   APB1总线时钟HCLK1： APB1总线时钟PCLK1由HCLK经过低速APB预分频器得到
   代码16-1设置系统时钟库函数：P137 static voidSetSysClockTo72(void)；
   

八、第17章 STM32中断应用概览

1. 每个外设都可以产生中断；

2. 异常类型：F103在内核水平上搭载了一个异常响应系统，支持为数众多的系统异常和外部中断

3. P146













