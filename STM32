一、第1-8章：

1. FSMC: flexible static memory controller;

2. AHB到APB桥：从AHB总线延伸出来两条APB2和APB1总线，我们常说的GPIO，串口，I2C，SPI这些外设就挂载在这两条总线上；

3. 系统总线：主要是访问外设的寄存器，即读写寄存器都是通过这根系统总线完成的；

4. RCC：P35，复位和时钟控制；

5. 存储器映射: 在图6-4中（P35），被控制单元的Flash, RAM, FSMC, 和AHB到APB桥（即片上外设），这些功能部件共同排列在一个4GB的地址空间内；

6. 存储器映射：给存储器分配地址的过程就称为存储器映射，见图6-5（P36）；

7. Block2：片上外设，地址范围 0x4000 0000 ~ 0x5FFF FFFF（512MB）

8. Block0: 内部Flash; Block1: 内部RAM；

9. 储存器Block2内部区域功能划分：根据外设的总线速度不同，被分成了APB和AHB两部分，其中APB又被分为APB1和APB2；

10. APB1总线外设：0x4000 0000 ~ 0x4000 77FF; APB2总线外设：0x4001 0000 ~ 0x4001 3FFF; AHP总线外设：0x4001 8000 ~ 0x5003 FFFF;

11. GPIO属于高速外设，挂载到APB2总线上，具体见表6-6（P39）；

12. GPIO是通用输入输出端口的简称，简单来说就是STM32可控制的引脚，基本功能是控制引脚输出高电平或低电平；

13. 每个GPI/O端口有2个32位配置寄存器（GPIOx_CRL, GPIOx_CRH），2个32位数据寄存器（GPIOx_IDR和GPIOx_ODR），1个32位置位/复位寄存器（GPIOx_BSRR），
    1个16位复位寄存器（GPIOx_BRR）和1个32位锁定寄存器（GPIOx_LCKR）;
    
14. 外设基地址：PERIPH_BASE; 在此基础上定义总线基地址：APB1PERIPH_BASE，APB2PERIPH_BASE, AHBPERIPH_BASE，在此基础上定义GPIO外设基地址：
    GPIOA_BASE, GPIOB_BASE, ... GPIOG_BASE; 在此基础上定义寄存器基地址（以GPIOB为例）：GPIOB_CRL, GPIOB_CRH, GPIOB_IDR, GPIOB_ODR, 
    GPIOB_BSRR, GPIOB_BRR, GPIOB_LCKR;
    
15. 最后，我们更进一步，直接使用宏定义好GPIO——TypeDef类型的指针，而且指针指向各个GPIO端口的首地址，使用时我们直接用该宏访问寄存器即可；
   （#define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)） P43
   
16. STM32芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。STM32芯片的GPIO被分成很多组，每组16个引脚，如GPIOA, GPIOB,
    ... GPIOG
    
17. 推挽输出&开漏输出模式：P55（STM32零死角）；

18. 推挽输出一般用在输出电平为0和3.3v而且需要高速切换开关状态的场合；

19. 开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中。除此之外，还用在电平不匹配的场合；

20. 输出数据寄存器：（P57）我们通过修改输出数据寄存器的值就可以修改GPIO引脚的输出电平。而“置位/复位寄存器GPIOx_BSRR”可以通过修改输出数据寄存器的
    值从而影响电路的输出；
    
21. 复用功能输出：（P57）“复用”是指STM32的其它片上外设对GPIO引脚进行控制，此时GPIO引脚用作该外设功能的一部分，算是第二用途；
    例如我们使用USART串口通讯时，需要用到某个GPIO引脚作为通讯发送引脚，这个时候就可以把该GPIO引脚配置成USART串口复用功能，由串口外设控制该引脚，发送数据；
    
22. 输入数据寄存器：（P57）看GPIO结构框图的上半部分，GPIO引脚经过内部的上、下拉电阻，可以配置成上/下拉输入，然后再连接到施密特触发器，信号经过
    触发器后，模拟信号转化为0、1的数字信号，然后存储在“输入数据寄存器GPIOx_IDR”中，通过读取该寄存器就可以了解GPIO引脚的电平状态；
    
23. 复用功能输入：（P58）与“复用功能输出”模式类似，在“复用功能输入模式”时，GPIO引脚的信号传输到STM32其它片上外设，由该外设读取引脚状态；

24. 模拟输入输出：（P58）STM32零死角

25. GPIO工作模式：（P58）GPIOMode_TypeDef：模拟输入，浮空输入，下拉输入，上拉输入，开漏输出，推挽输出，复用开漏输出，复用推挽输出；

26. 输入模式（模拟/浮空/上拉/下拉）：（P58）在输入模式时，施密特触发器打开，输出被禁止，可以通过输入数据寄存器GPIOx_IDR读取I/O状态；
    其中输入模式，可设置为上拉、下拉、浮空和模拟输入四种。上拉和下拉输入很好理解，默认的电平由上拉或者下拉决定。浮空输入的电平是不确定的，
    完全由外部的输入决定，一般接按键的时候用的是这个模式。模拟输入则用于 ADC 采集；
    
27. 输出模式（推挽/开漏）: （P59） 在输出模式中，推挽模式时双 MOS 管以轮流方式工作，输出数据寄存器 GPIOx_ODR可控制 I/O 输出高低电平。
    开漏模式时，只有 N-MOS 管工作，输出数据寄存器可控制 I/O输出高阻态或低电平。输出速度可配置，有 2MHz\10MHz\50MHz 的选项。
    此处的输出速度即 I/O 支持的高低电平状态最高切换频率，支持的频率越高，功耗越大，如果功耗要求不严格，把速度设置成最大即可。
    在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器 GPIOx_IDR可读取 I/O 的实际状态。
    
28. 复用功能（推挽/开漏）：复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出信号源于其它外设，输出数据寄存器 GPIOx_ODR 
    无效；输入可用，通过输入数据寄存器可获取 I/O 实际状态，但一般直接用外设的寄存器来获取该数据信号；通过对 GPIO 寄存器写入不同的参数，
    就可以改变 GPIO 的工作模式，
    在 GPIO 外设中，控制端口高低控制寄存器 CRH 和 CRL 可以配置每个 GPIO 的工作模式和工作的速度，每 4 个位控制一个 IO，CRH 控制端口的高八位，
    CRL 控制端口的低 8 位，具体的看 CRH 和 CRL 的寄存器描述；

29. GPIOx_CRL & GPIOx_CRH: 每个引脚占用4个寄存器位。MODE位用来配置输出的速度，CNF位用来配置各种输入输出模式；

30. 控制引脚输出电平：（P66）在输出模式时，对端口位设置/清除寄存器BSRR寄存器、端口位清除寄存器BRR和ODR寄存器写入参数即可控制引脚的电平状态，其中
    操作BSRR和BRR最终影响的都是ODR寄存器，然后再通过ODR寄存器的输出来控制GPIO；
    
31. 开启外设时钟：由于STM32的外设很多，为了降低功耗，每个外设都对应着一个时钟，在芯片刚上电的时候这些时钟都是被关闭的，如果想要外设工作，必须把
    相应的时钟打开。STM32 的所有外设的时钟由一个专门的外设来管理，叫RCC（reset and clockcontrol），RCC 在《STM32 中文参考手册》的第六章。
    所有的GPIO都挂载到APB2总线上，具体的时钟由APB2外设时钟使能寄存器(RCC_APB2ENR)来控制；
    图8-11APB2外设时钟使能寄存器（P68）
    

二、第9章 自己写库—构建库函数雏形

1. APB2外设时钟使能寄存器(RCC_APB2ENR) ：STM32F01x-中文参考手册 P70；

2. 定义位操作函数：玩转STM32 P73
    voidGPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_tGPIO_Pin)，函数功能：设置引脚为高电平；
    voidGPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_tGPIO_Pin)，函数功能：设置引脚为低电平；
    
3. /*GPIO引脚号定义*/： 玩转STM32 P75
   GPIO_Pin_0, ... GPIO_Pin_15;
   
4. 定义初始化结构体GPIO_InitTypeDef:（P76）定义位操作函数后，控制GPIO输出电平的代码得到了简化，但在控制GPIO输出电平前还需要初始化GPIO引脚的各种模式

5. 定义引脚模式的枚举类型：（P77）GPIOSpeed_TypeDef 和 GPIOMode_TypeDef；
   代码9-5使用枚举定义的GPIO初始化结构体：P79；
   代码清单9-7给GPIO_InitTypeDef初始化结构体赋值范例：P79
   
6. 定义GPIO初始化函数：P80 接着前面的思路，对初始化结构体赋值后，把它输入到GPIO初始化函数，由它来实现寄存器配置。我们的GPIO初始化函数实现见代码9-6。
   voidGPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)


三、初识STM32标准库

1. 常用官方资料：P93


四、第12章 GPIO输出—使用固件库点亮LED

1. GPIO时钟宏“RCC_APB2Periph_GPIOB：是STM32标准库定义的GPIO端口时钟相关的宏，它的作用与“GPIO_Pin_x”这类宏类似，是用于指示寄存器位的，方便库函数使用；使用

2. RCC_APB2PeriphClockCmd：（P110） 调用库函数RCC_APB2PeriphClockCmd来使能LED灯的GPIO端口时钟；
   GPIO_Init：调用库函数，初始化GPIO；


五、第13章 GPIO输入—按键检测

1. 编程要点：
   （1）使能GPIO端口时钟；（2）初始化GPIO目标引脚为输入模式(浮空输入)；（3）编写简单测试程序，检测按键的状态，实现按键控制LED灯。
   
2. GPIO_ReadInputDataBit(GPIOx,GPIO_Pin)：STM32标准库提供了库函数GPIO_ReadInputDataBit来获取位状态，该函数输入GPIO端口及引脚号，函数
   返回该引脚的电平状态，高电平返回1，低电平返回0；
   

六、第14章 GPIO—位带操作

1. 位带简介：
   在STM32中，有两个地方实现了位带，一个是SRAM区的最低1MB空间，令一个是外设区最低1MB空间。这两个1MB的空间除了可以像正常的RAM一样操作外，他们还有
   自己的位带别名区，位带别名区把这1MB的空间的每一个位膨胀成一个32位的字，当访问位带别名区的这些字时，就可以达到访问位带区某个比特位的目的。
   P121；
   
2. STM32 的全部寄存器都可以通过访问位带别名区的方式来达到访问原始寄存器比特位的效果；


七、第16章 RCC—使用 HSE/HSI 配置时钟

1. RCC 主要作用—时钟部分：
   设置系统时钟 SYSCLK、设置 AHB 分频因子（决定 HCLK 等于多少）、设置 APB2 分频因子（决定 PCLK2 等于多少）、设置 APB1 分频因子（决定 PCLK1 
   等于多少）、设置各个外设的分频因子；控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。对于 SYSCLK、HCLK、PCLK2、PCLK1 
   这四个时钟的配置一般是：PCLK2 = HCLK = SYSCLK=PLLCLK = 72M，PCLK1=HCLK/2 = 36M。这个时钟配置也是库函数的标准配置，我们用的最多的就是这个；
   
2. 图 16-1 STM32 时钟树：P135

3. HSE 高速外部时钟信号；
   PLL 时钟源：PLL时钟来源可以有两个，一个来自HSE，另外一个是HSI/2，具体用哪个由时钟配置寄存器CFGR的位16：PLLSRC设置。HSI是内部高速的时钟信号
   PLL时钟PLLCLK
   系统时钟SYSCLK：系统时钟来源可以是：HSI、PLLCLK、HSE，具体的时钟配置寄存器CFGR的位1-0：SW[1:0]设置
   AHB总线时钟HCLK：系统时钟SYSCLK经过AHB预分频器分频之后得到时钟叫APB总线时钟，即HCLK
   APB2总线时钟HCLK2：APB2总线时钟PCLK2由HCLK经过高速APB2预分频器得到，分频因子可以是:[1,2,4，8，16]，具体由时钟配置寄存器CFGR的位13-11：PPRE2[2:0]决定
   APB1总线时钟HCLK1： APB1总线时钟PCLK1由HCLK经过低速APB预分频器得到
   代码16-1设置系统时钟库函数：P137 static voidSetSysClockTo72(void)；
   

八、第17章 STM32中断应用概览

1. 每个外设都可以产生中断；

2. 异常类型：F103在内核水平上搭载了一个异常响应系统，支持为数众多的系统异常和外部中断

3. NVIC简介：NVIC是嵌套向量中断控制器，控制着整个芯片中断相关的功能，它跟内核紧密耦合，是内核里面的一个外设；

4. 在配置中断的时候我们一般只用ISER、ICER和IP这三个寄存器，ISER用来使能中断，ICER用来失能中断，IP用来设置中断优先级。

5. 表格17-3符合CMSIS标准的NVIC库函数：P147

6. 中断优先级：在NVIC 有一个专门的寄存器：中断优先级寄存器NVIC_IPRx，用来配置外部中断的优先级；
   用于表达优先级的这4bit，又被分组成抢占优先级和子优先级。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行，如果抢占优先级
   相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。
   
7. 优先级分组：优先级的分组由内核外设SCB的应用程序中断及复位控制寄存器AIRCR的PRIGROUP[10:8]位决定 P148
   设置优先级分组可调用库函数： 16 voidNVIC_PriorityGroupConfig(uint32_tNVIC_PriorityGroup)，有关NVIC中断相关的库函数都在库文件misc.c和misc.h中。

8. 中断编程：在配置每个中断的时候一般有3个编程要点：
   1、使能外设某个中断，这个具体由每个外设的相关中断使能位控制。比如串口有发送完成中断，接收完成中断，这两个中断都由串口控制寄存器的相关中断使能位控制；
   2、初始化NVIC_InitTypeDef结构体，配置中断优先级分组，设置抢占优先级和子优先级，使能中断请求。NVIC_InitTypeDef结构体在固件库头文件misc.h中定义
      P149
      1）NVIC_IROChannel：用来设置中断源，不同的中断中断源不一样，且不可写错，即使写错了程序也不会报错，只会导致不响应中断。具体的成员配置可参考
      stm32f10x.h头文件里面的IRQn_Type结构体定义，这个结构体包含了所有的中断源。
   3、编写中断服务函数
      在启动文件startup_stm32f10x_hd.s中我们预先为每个中断都写了一个中断服务函数，只是这些中断函数都是为空，为的只是初始化中断向量表。实际的中断
      服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在stm32f10x_it.c这个库文件中。
      
   
九、第18章 EXTI—外部中断/事件控制器

1. EXTI简介：EXTI（External interrupt/event controller）—外部中断/事件控制器，管理了控制器的20 个中断/事件线。每个中断/事件线都对应有一个边沿
   检测器，可以实现输入信号的上升沿检测和下降沿的检测。EXTI可以实现对每个中断/事件线进行单独配置，可以单独配置为中断或者事件，以及触发事件的属性。
   
2. EXTI功能框图： P151
   EXTI可分为两大部分功能，一个是产生中断，另一个是产生事件，这两个功能从硬件上就有所不同；
   首先我们来看图18-1中红色虚线指示的电路流程。它是一个产生中断的线路，最终信号流入到NVIC控制器内；
   接下来我们来看看绿色虚线指示的电路流程。它是一个产生事件的线路，最终输出一个脉冲信号；
   产生中断线路目的是把输入信号输入到NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用，
   并且是电路级别的信号传输，属于硬件级的；
   另外，EXTI是在APB2总线上的，在编程时候需要注意到这点；
   
3. 中断/事件线：EXTI有20个中断/事件线，每个GPIO都可以被设置为输入线，占用EXTI0至EXTI15，还有另外七根用于特定的外设事件，见表18-1。
   4根特定外设中断/事件线由外设触发，具体用法参考《STM32F10X-中文参考手册》中对外设的具体说明。
   
   EXTI0至EXTI15用于GPIO，通过编程控制可以实现任意一个GPIO作为EXTI的输入源。由表18-1可知，EXTI0可以通过AFIO的外部中断配置寄存器1(AFIO_EXTICR1)
   的EXTI0[3:0]位选择配置为PA0、PB0、PC0、PD0、PE0、PF0、PG0、PH0或者PI0，见图18-2。其他EXTI线(EXTI中断/事件线)使用配置都是类似的。
   
4. AFIO: 
   AFIO简介：其实，（二）中所述的问题都是管脚复用的问题。MCU不仅CPU需要管脚而且内置外设也需要管脚，但是STM32的管脚数量是有限的，这就导致了有的管脚
   不仅是作为普通IO的存在，更是作为外设IO的存在，这就是管脚复用现象。而普通管脚就是GPIO，复用管脚就是我们所说的AFIO。也就是说，如果要用到外设功能，
   则必须要用的到外设IO（即AFIO）
   P153
   stm32中文参考手册：P116
   
   对寄存器AFIO_EVCR，AFIO_MAPR和AFIO_EXTICRX进行读写操作前，应当首先打开AFIO的时钟。参考第6.3.7节APB2外设时钟使能寄存器(RCC_APB2ENR)；
   事件控制寄存器(AFIO_EVCR)；
   复用重映射和调试I/O配置寄存器(AFIO_MAPR)；
   外部中断配置寄存器 1(AFIO_EXTICR1)；
   外部中断配置寄存器 2(AFIO_EXTICR2)；
   外部中断配置寄存器 3(AFIO_EXTICR3)；
   外部中断配置寄存器 4(AFIO_EXTICR4)；
   
   
   参考：https://blog.csdn.net/qq_43174086/article/details/97028280
   
5. EXTI初始化结构体详解
   标准库函数对每个外设都建立了一个初始化结构体，比如EXTI_InitTypeDef，结构体成员用于设置外设工作参数，并由外设初始化配置函数，比如EXTI_Init()调用，
   这些设定参数将会设置外设相应的寄存器，达到配置外设工作环境的目的；
   
   初始化结构体和初始化库函数配合使用是标准库精髓所在，理解了初始化结构体每个成员意义基本上就可以对该外设运用自如了。初始化结构体定义在stm32f4xx_exti.h
   文件中，初始化库函数定义在stm32f4xx_exti.c文件中，编程时我们可以结合这两个文件内注释使用；
   P154
   
   代码清单18-1EXTI初始化结构体：P154
   1）EXTI_Line：EXTI中断/事件线选择，可选EXTI0至EXTI19，可参考表18-1选择；
   2）EXTI_Mode：EXTI模式选择，可选为产生中断(EXTI_Mode_Interrupt)或者产生事件(EXTI_Mode_Event)；
   3）EXTI_Trigger：EXTI边沿触发事件，可选上升沿触发(EXTI_Trigger_Rising)、下降沿触发(EXTI_Trigger_Falling)或者上升沿和下降沿都触发(EXTI_Trigger_Rising_Falling)；
   4）EXTI_LineCmd：控制是否使能EXTI线，可选使能EXTI线(ENABLE)或禁用(DISABLE)；
   
6. 外部中断控制实验： P155
   编程要点：
   1）初始化用来产生中断的GPIO； 
   2）初始化EXTI； 
   3）配置NVIC； 
   4）编写中断服务函数；
   
   EXTI_GetITStatus函数用来获取EXTI的中断标志位状态，如果EXTI线有中断发生函数返回“SET”否则返回“RESET”。实际上，EXTI_GetITStatus函数是通过读取
   EXTI_PR寄存器值来判断EXTI线状态的；
   
   执行任务后需要调用EXTI_ClearITPendingBit函数清除EXTI线的中断标志位；
   
7. GPIO_EXTILineConfig函数用来指定中断/事件线的输入源，它实际是设定外部中断配置寄存器的AFIO_EXTICRx值，该函数接收两个参数，第一个参数指定GPIO端口
   源，第二个参数为选择对应GPIO引脚源编号；
   
8. 使用GPIO之前必须开启GPIO端口的时钟；用到EXTI必须开启AFIO时钟；


十、第19章 SysTick—系统定时器

1. SysTick简介：
   SysTick—系统定时器是属于CM3内核中的一个外设，内嵌在NVIC中。系统定时器是一个24bit的向下递减的计数器，计数器每计数一次的时间为1/SYSCLK，一般我们
   设置系统时钟SYSCLK等于72M。当重装载数值寄存器的值递减到0的时候，系统定时器就产生一次中断，以此循环往复；
   
   SysTick—系统定时器有4个寄存器，简要介绍如下。在使用SysTick产生定时的时候，只需要配置前三个寄存器，最后一个校准寄存器不需要使用；
   表19-1SysTick寄存器汇总 P160
   
2. SysTick定时实验：
   编程要点：
   1、设置重装载寄存器的值
   2、清除当前数值寄存器的值
   3、配置控制与状态寄存器
   SysTick 属于内核的外设，有关的寄存器定义和库函数都在内核相关的库文件core_cm3.h中；
   
   SysTick配置库函数：__STATIC_INLINE uint32_tSysTick_Config(uint32_tticks)
   P162
   用固件库编程的时候我们只需要调用库函数SysTick_Config()即可，形参ticks用来设置重装载寄存器的值，最大不能超过重装载寄存器的值224，当重装载寄存器
   的值递减到0的时候产生中断，然后重装载寄存器的值又重新装载往下递减计数，以此循环往复。紧随其后设置好中断优先级，最后配置系统定时器的时钟等于
   AHBCLK=72M，使能定时器和定时器中断，这样系统定时器就配置好了，一个库函数搞定；
   
   SysTick_Config()库函数主要配置了SysTick中的三个寄存器：LOAD、VAL和CTRL，有关具体的部分看代码注释即可；
   
   配置SysTick中断优先级：在SysTick_Config()库函数还调用了固件库函数NVIC_SetPriority()来配置系统定时器的中断优先级，该库函数也在core_m3.h中定义；
   因为SysTick属于内核外设，跟普通外设的中断优先级有些区别，并没有抢占优先级和子优先级的说法。在STM32F103中，内核外设的中断优先级由内核SCB这个外设的
   寄存器：SHPRx（x=1.2.3）来配置。有关SHPRx寄存器的详细描述可参考《Cortex-M3内核编程手册》4.4.8章节；
   
   SysTick初始化函数：voidSysTick_Init(void)
   SysTick初始化函数由用户编写，里面调用了SysTick_Config()这个固件库函数，通过设置该固件库函数的形参，就决定了系统定时器经过多少时间就产生一次中断。
   
   SysTick中断时间的计算：
   SysTick定时器的计数器是向下递减计数的，计数一次的时间TDEC=1/CLKAHB，当重装载寄存器中的值VALUELOAD减到0的时候，产生中断，可知中断一次的时间
   TINT=VALUELOAD* TDEC=VALUELOAD/CLKAHB，其中CLKAHB=72MHZ。如果设置VALUELOAD为72，那中断一次的时间TINT=72/72M=1us。不过1us的中断没啥意义，
   整个程序的重心都花在进出中断上了，根本没有时间处理其他的任务；
   
   SysTick定时时间的计算：
   当设置好中断时间TINT后，我们可以设置一个变量t，用来记录进入中断的次数，那么变量t乘以中断的时间TINT就可以计算出需要定时的时间；
   
   SysTick定时函数：
   
   SysTick中断服务函数：voidSysTick_Handler(void)；
   
   
十一、第20章 通讯的基本概念

1. 
   
   













